// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: reconciliation_jobs.sql

package dbgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgtype"
)

const countReconciliationJobs = `-- name: CountReconciliationJobs :one
SELECT COUNT(1) FROM reconciliation_jobs
`

func (q *Queries) CountReconciliationJobs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countReconciliationJobs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReconciliationJob = `-- name: CreateReconciliationJob :one
INSERT INTO reconciliation_jobs (status, system_transaction_csv_path, bank_transaction_csv_paths, discrepancy_threshold, start_date, end_date) VALUES ('PENDING', $1, $2, $3, $4, $5)
RETURNING id, status, system_transaction_csv_path, bank_transaction_csv_paths, discrepancy_threshold, start_date, end_date, result, created_at, updated_at, error_information
`

type CreateReconciliationJobParams struct {
	SystemTransactionCsvPath string       `db:"system_transaction_csv_path"`
	BankTransactionCsvPaths  pgtype.JSONB `db:"bank_transaction_csv_paths"`
	DiscrepancyThreshold     float64      `db:"discrepancy_threshold"`
	StartDate                time.Time    `db:"start_date"`
	EndDate                  time.Time    `db:"end_date"`
}

func (q *Queries) CreateReconciliationJob(ctx context.Context, arg CreateReconciliationJobParams) (ReconciliationJob, error) {
	row := q.db.QueryRow(ctx, createReconciliationJob,
		arg.SystemTransactionCsvPath,
		arg.BankTransactionCsvPaths,
		arg.DiscrepancyThreshold,
		arg.StartDate,
		arg.EndDate,
	)
	var i ReconciliationJob
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.SystemTransactionCsvPath,
		&i.BankTransactionCsvPaths,
		&i.DiscrepancyThreshold,
		&i.StartDate,
		&i.EndDate,
		&i.Result,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ErrorInformation,
	)
	return i, err
}

const getReconciliationJobById = `-- name: GetReconciliationJobById :one
SELECT id, status, system_transaction_csv_path, bank_transaction_csv_paths, discrepancy_threshold, start_date, end_date, result, created_at, updated_at, error_information FROM reconciliation_jobs WHERE id = $1
`

func (q *Queries) GetReconciliationJobById(ctx context.Context, id int64) (ReconciliationJob, error) {
	row := q.db.QueryRow(ctx, getReconciliationJobById, id)
	var i ReconciliationJob
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.SystemTransactionCsvPath,
		&i.BankTransactionCsvPaths,
		&i.DiscrepancyThreshold,
		&i.StartDate,
		&i.EndDate,
		&i.Result,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ErrorInformation,
	)
	return i, err
}

const listPendingReconciliationJobs = `-- name: ListPendingReconciliationJobs :many
SELECT id, status, system_transaction_csv_path, bank_transaction_csv_paths, discrepancy_threshold, start_date, end_date, result, created_at, updated_at, error_information FROM reconciliation_jobs
WHERE status = 'PENDING'
ORDER BY created_at ASC
`

func (q *Queries) ListPendingReconciliationJobs(ctx context.Context) ([]ReconciliationJob, error) {
	rows, err := q.db.Query(ctx, listPendingReconciliationJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReconciliationJob
	for rows.Next() {
		var i ReconciliationJob
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.SystemTransactionCsvPath,
			&i.BankTransactionCsvPaths,
			&i.DiscrepancyThreshold,
			&i.StartDate,
			&i.EndDate,
			&i.Result,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ErrorInformation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReconciliationJobs = `-- name: ListReconciliationJobs :many
SELECT id, status, system_transaction_csv_path, bank_transaction_csv_paths, discrepancy_threshold, start_date, end_date, result, created_at, updated_at, error_information FROM reconciliation_jobs
ORDER BY id DESC
LIMIT $1 OFFSET $2
`

type ListReconciliationJobsParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) ListReconciliationJobs(ctx context.Context, arg ListReconciliationJobsParams) ([]ReconciliationJob, error) {
	rows, err := q.db.Query(ctx, listReconciliationJobs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReconciliationJob
	for rows.Next() {
		var i ReconciliationJob
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.SystemTransactionCsvPath,
			&i.BankTransactionCsvPaths,
			&i.DiscrepancyThreshold,
			&i.StartDate,
			&i.EndDate,
			&i.Result,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ErrorInformation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveFailedReconciliationJob = `-- name: SaveFailedReconciliationJob :one
UPDATE reconciliation_jobs SET status = 'FAILED', error_information = $2 WHERE id = $1 RETURNING id, status, system_transaction_csv_path, bank_transaction_csv_paths, discrepancy_threshold, start_date, end_date, result, created_at, updated_at, error_information
`

type SaveFailedReconciliationJobParams struct {
	ID               int64          `db:"id"`
	ErrorInformation sql.NullString `db:"error_information"`
}

func (q *Queries) SaveFailedReconciliationJob(ctx context.Context, arg SaveFailedReconciliationJobParams) (ReconciliationJob, error) {
	row := q.db.QueryRow(ctx, saveFailedReconciliationJob, arg.ID, arg.ErrorInformation)
	var i ReconciliationJob
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.SystemTransactionCsvPath,
		&i.BankTransactionCsvPaths,
		&i.DiscrepancyThreshold,
		&i.StartDate,
		&i.EndDate,
		&i.Result,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ErrorInformation,
	)
	return i, err
}

const saveSuccessReconciliationJob = `-- name: SaveSuccessReconciliationJob :one
UPDATE reconciliation_jobs SET status = 'SUCCESS', result = $2 WHERE id = $1 RETURNING id, status, system_transaction_csv_path, bank_transaction_csv_paths, discrepancy_threshold, start_date, end_date, result, created_at, updated_at, error_information
`

type SaveSuccessReconciliationJobParams struct {
	ID     int64        `db:"id"`
	Result pgtype.JSONB `db:"result"`
}

func (q *Queries) SaveSuccessReconciliationJob(ctx context.Context, arg SaveSuccessReconciliationJobParams) (ReconciliationJob, error) {
	row := q.db.QueryRow(ctx, saveSuccessReconciliationJob, arg.ID, arg.Result)
	var i ReconciliationJob
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.SystemTransactionCsvPath,
		&i.BankTransactionCsvPaths,
		&i.DiscrepancyThreshold,
		&i.StartDate,
		&i.EndDate,
		&i.Result,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ErrorInformation,
	)
	return i, err
}
